
    React
    
    1. 리액트란 ? 
        
        목적 : 동적으로 사용자 친화적으로 웹 서비스가 변화하면서 사용자에게 더 좋은 UX와 UI를 제공하기 위함이다.
        정의 : 사용자 인터페이스를 만들기 위한 자바스크립트 라이브러리
               리액트는 동적으로 변하는 state를 가지고 있는데, 이 state가 변할 때 UI를 자동으로 업데이트해주는 JS라이브러리
        구조 : 가상 DOM을 사용하여 변경될 부분만 효율적으로 업데이트를 해준다. (Why? UI가 변할 때 화면을 갈아엎으면 자원 손실이 크기 때문에)
    
    2. 리액트의 특징

        * Components : UI를 구성하는 개별적인 뷰(View)단위로써, 완성된 UI가 레고라면 컴포넌트는 블록 역할을 한다.
                       이러한 특징은 하나의 컴포넌트를 여러 부분에서 사용할 수 있게 해준다.
                       예로, 어플리케이션에 여러 버튼이 필요하면, 공통된 하나의 컴포넌트를 생성하고 그 컴포넌트를 필요한 곳에 사용하면 된다.
                       
                       따라서 이는 생산성과 유지보수에 용이한 이점이 있고, 요소의 변화가 다른 요소들에 변화에 영향을 미치는 복잡한 로직을
                       업데이트하는 까다로는 작업의 경우, 컴포넌트의 재사용 기능으로 보완할 수 있다. 

        예시) :  - 수업시간 App.js의 내용

                import {
                  RouterProvider,
                } from "react-router-dom";

                import router from "./routes/route";
                import GlobalStyles from "styles/global.style";
                import { ThemeProvider } from "styled-components";
                import theme from "styles/theme.style";

                function App() { 
                  return <ThemeProvider theme={theme}>
                    <GlobalStyles/>
                    <RouterProvider router={router} />
                  </ThemeProvider>

                }

                (컴포넌트들로 묶어주자 가독성이 뛰어나진 모습.)
                위와 같이 한페이지에 모두 넣는 것이 아닌, 관리 효율성을 높이기 위해 route, global.style, theme.style 등과 같이 
                각각을 컴포넌트로 나누고 이를 불러오는 형태로 진행되고 있다. 

                
                - 수업시간 index.js의 내용

                import React from 'react';
                import ReactDOM from 'react-dom/client';
                import './index.css';
                import App from './App';
                import reportWebVitals from './reportWebVitals';

                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                  <React.StrictMode>
                    <App />
                  </React.StrictMode>
                );


                또한, 각각의 컴포넌트를 불러와 구성된 App.js는 다시 index.js의 하위 컴포넌트로 구성되어 불러읽음으로써 랜더링하고 있다.
                이렇게 분리되어진 컴포넌트들은 계속 재사용되어질 수 있고, 반복되는 개발의 시간도 단축될뿐만아니라 디버깅도 쉽게 할 수 있다.

                
        반복되어 재사용되어진 예시) 수업내용 중 button.js

                import { css, styled } from "styled-components"

                const SHButton = ({variant, size, shape, children}) => {
                
                    return (<Button variant={variant} size={size} shape={shape}>
                        {children}</Button>
                    )
                }


                예시-1) 수업 내용 중 SignInForm.js 

                import SHButton from "components/button"

                const SignInForm = () => {
                  return <S.Form>
                  내용 생략 ... 
                  <SHButton variant={'primary'} size={"full"} shape={"shape"}>
                    로그인</SHButton>
                </S.Form>
                }

                예시-2) 수업 내용 중 SignUpForm.js

                import SHButton from "components/button"

                const SignUpForm = () => {
                  return <S.Form>
                  내용 생략...
                  <SHButton shape={'shape'} size={'full'} variant={'primary'}>회원가입</SHButton>
                </S.Form>
                }


                위와 같이 반복되어진 button은 컴포넌트화시켜 재사용되어진 모습을 알 수 있다.

                


        * Virtual DOM : 실제 DOM을 변경하기 전에 메모리상에서 구성하는 가짜 DOM을 말한다.
                        이는 변경사항을 한번에 구성해서 반영하기 위한 도구이다.
        
                        Virtual DOM은 변화가 발생하면, 실제 DOM에 적용되기 전에 Virtual DOM에 우선 적용을 시켜본다. 
                        실제 DOM에 바로 적용하나, Virtual DOM에 적용하나 같은 연산 비용이 필요할 거라 생각할 수 있지만, 
                        Virtual DOM은 랜더링 과정이 필요 없기 때문에 연산 비용이 실제 DOM보다 적다.
                        따라서, 리액트는 변경하고자하는 부분만 업데이트가 가능하다!

                        리액트는 동적으로 변화하는 UI를 만들기 위해서 사용하는데, 그 이유 때문에
                        동적으로 값이 변하는 State를 갖고 있고, 이 State가 변할 때 ui를 자동으로 업데이트 해주는 역할을 갖고 있다.


        예시) 
                import {useState} from 'react';

                let [like,setLike] = useState(0)    // like 가 state고, setLike는 state의 값을 변경해주는 함수이다. 이름은 마음대로 바꿀 수 있다
                                                    // like에는 0이라는 값이 들어간다.

                <div>
                  <span onClick={function(){
                    setLike(like+1)                 //좋아요 개수 1 올려주는 함수이다. 
                  }>좋아요</span> {like[0]}         //{like[0]} 으로 state를 사용할 수 있다.
                <div>

                        state는 일반 변수들과 달리 값이 변경되면 화면에 변경된 값이 바로 랜더링 된다.


    3. 리액트의 단점

        1) 학습 곡선: 리액트는 처음 사용하는 개발자에게는 학습 곡선이 가파를 수 있다. 
           JSX 문법이나 컴포넌트 기반 아키텍처같은 새로운 개념을 익히는 데 시간이 걸릴 수 있다. 
           또한 리액트는 상태 관리와 라우팅 같은 추가 라이브러리와 함께 사용될 때 더욱 복잡해질 수 있다.

        2) 복잡한 구조: 리액트는 컴포넌트 기반 아키텍처로 되어있어, 큰 규모의 애플리케이션을 개발할 때 구조를 관리하기 어려울 수 있다. 
           컴포넌트 간의 의존성이 높아지면 코드가 복잡해지고 유지보수가 어려워질 수 있다.
        
        3) 성능 문제: 리액트는 가상 DOM(Virtual DOM)을 사용하여 화면 업데이트를 최적화한다. 
           그러나 컴포넌트의 수가 많거나 복잡한 동작이 필요한 경우, 가상 DOM의 비교 알고리즘이 병목 현상을 일으킬 수 있다. 
           이 때문에 성능 저하가 발생할 수 있고, 최적화를 위해 추가적인 노력이 필요할 수 있다.
        
        4) 바이러블리티: 리액트는 컴포넌트의 상태 변화에 따라 화면을 업데이트하는데, 
           상태 변화를 정확히 추적하기 위해서는 데이터 흐름을 정확히 파악해야 한다. 
           상태 관리가 제대로 이루어지지 않으면 예상치 못한 동작이 발생할 수 있다. 
           바이러블리티는 불필요한 컴포넌트 업데이트를 초래할 수 있고, 애플리케이션의 성능을 해칠 수 있다.
        
        5) 생태계 문제: 리액트는 개발자들 사이에서 매우 인기 있는 라이브러리지만, 이로 인해 너무 많은 라이브러리와 도구가 생태계에 존재한다. 
           이 때문에 개발자들이 선택에 어려움을 겪고, 프로젝트에 적합한 도구를 선택하는 데 시간과 노력이 필요할 수 있다.





